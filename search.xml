<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo 个人博客创建</title>
    <url>/Node/Hexo%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%20%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="快速搭建hexo个人博客"><a href="#快速搭建hexo个人博客" class="headerlink" title="快速搭建hexo个人博客"></a>快速搭建hexo个人博客</h1><p>​        本文介绍简单搭建hexo个人博客，其他升阶的功能不在此详述。</p>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p>本地需求</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">node.js</span><br><span class="line">npm(cnpm 使用淘宝镜像源)</span><br><span class="line">github账号</span><br><span class="line">个人域名(非必要)</span><br></pre></td></tr></table></figure>
<p>个人环境信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Windows 10</span><br><span class="line">node.js ver12.16.1</span><br><span class="line">npm ver6.13.4</span><br></pre></td></tr></table></figure>
<h3 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h3><p>​    使用github pages作为服务器搭建博客比起传统搭建过程更为简单</p>
<p>​    创建GitHub仓库，名字格式必须为:你的用户名.github.io,假如你的用户名为userdemo,则仓库名为userdemo.github.io.</p>
<h3 id="Windows安装git-bash"><a href="#Windows安装git-bash" class="headerlink" title="Windows安装git bash"></a>Windows安装git bash</h3><p>​    在<a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a> 安装git bash命令行工具。至于git的基本操作可以去看廖雪峰老师的git教程<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
<p>​    安装完毕后，进入git bash,输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"你的邮件地址"</span></span></span><br></pre></td></tr></table></figure>
<p>生成ssh密钥，连续回车生成密钥文件，默认在用户目录下的.ssh\id_rsa.pub文件，用记事本打开复制里面的代码，登录github,点击用户下拉栏里的Settings，选择左侧SSH and GPG keys配置密钥(标题无限制)。</p>
<p><img src="https://i.loli.net/2020/06/04/XHiKefl9FmZ6OJD.png" alt=""></p>
<p>在git bash里输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br></pre></td></tr></table></figure>
<p>若密钥配置成功则如下</p>
<p><img src="https://i.loli.net/2020/06/04/j9CM8yQ65cx4zit.png" alt=""></p>
<p>接着配置本地用户信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"你的github用户名"</span> </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"你的github注册邮箱"</span></span></span><br></pre></td></tr></table></figure>
<h3 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h3><ol>
<li>下载安装（PS：安装中注意选择Add to path配置环境变量)&lt;-Node官网<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></li>
<li>安装结束后输入</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>确认Node与npm的版本</p>
<p>​    3.设置淘宝镜像源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>之后使用npm install <em>改用cnpm install</em>会大幅度提升下载速度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install *</span><br></pre></td></tr></table></figure>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init blog # blog为你的项目名</span><br><span class="line">cd blog</span><br><span class="line">cnpm install # 安装模块</span><br><span class="line">hexo s #开启服务器 s = server</span><br></pre></td></tr></table></figure>
<p>hexo常见指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>No</th>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>hexo server 或 hexo s</td>
<td>启动服务器</td>
</tr>
<tr>
<td>2</td>
<td>hexo generate</td>
<td>生成静态页面到public目录</td>
</tr>
<tr>
<td>3</td>
<td>hexo new page pagename</td>
<td>新建页面(pagename=页面名)</td>
</tr>
<tr>
<td>4</td>
<td>hexo new article</td>
<td>新建文章(article=文章名)</td>
</tr>
<tr>
<td>5</td>
<td>hexo deploy 或 hexo d</td>
<td>将hexo部署到github</td>
</tr>
<tr>
<td>6</td>
<td>hexo clean</td>
<td>清空生成</td>
</tr>
</tbody>
</table>
</div>
<p>输入hexo server启用服务器，在localhost:4000 预览界面。</p>
<h2 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h2><p>在项目根目录里配置_config.yml(PS : yml格式的键值对冒号后有一个空格)</p>
<h3 id="网站参数"><a href="#网站参数" class="headerlink" title="网站参数"></a>网站参数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>网站总标题</td>
</tr>
<tr>
<td>subtitle</td>
<td>网站子标题</td>
</tr>
<tr>
<td>description</td>
<td>网站描述</td>
</tr>
<tr>
<td>author</td>
<td>发布者名</td>
</tr>
<tr>
<td>language</td>
<td>语言</td>
</tr>
<tr>
<td>timezone</td>
<td>时区:GMT、UTC等</td>
</tr>
</tbody>
</table>
</div>
<h3 id="网址参数"><a href="#网址参数" class="headerlink" title="网址参数"></a>网址参数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td>你的网站的域名</td>
</tr>
<tr>
<td>root</td>
<td>根目录</td>
</tr>
<tr>
<td>permalink</td>
<td>文章格式</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">permalink</span> <span class="comment">#格式：</span></span><br><span class="line">	<span class="string">:year/:month/:day/:title/</span> <span class="comment">#年/月/日/标题/</span></span><br><span class="line">	<span class="string">:year-:month-:day-:title.html</span> <span class="comment">#年-月-日-标题</span></span><br><span class="line">	<span class="string">:category/:title/</span> <span class="comment"># 分类/标题/</span></span><br></pre></td></tr></table></figure>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span></span><br></pre></td></tr></table></figure>
<p>配置其他主题（以next为例，更多见<a href="https://hexo.io/themes" target="_blank" rel="noopener">https://hexo.io/themes</a>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure>
<p>在项目根目录里鼠标右键点击git bash里将其克隆到本地工程中；再将上述theme的值修改为next,此时使用hexo clean先清空一下缓存，再使用hexo s启动服务器。</p>
<p>更多next的配置见<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p>
<h2 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h2><p>使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page pagename #pagename = 你的页面名</span><br></pre></td></tr></table></figure>
<p>创建新的页面，在你的项目根目录打开source文件夹可以看见你刚才创建的页面的目录，打开里面的inedx.md.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">上述md打开的三根杠见配置页面信息，，一般默认有title: 文章的文件名，data: 生成日期。</span><br><span class="line">其余参数配置以及教程见 https://hexo.io/zh-cn/docs/front-matter</span><br></pre></td></tr></table></figure>
<p>以下以建立标签tags页为例创建tags页面：</p>
<p>输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>进入根目录下的source的tags配置index.md，配置type: “tags”</p>
<p>在文章的md中设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章名</span><br><span class="line">data: 日期</span><br><span class="line">tags: </span><br><span class="line">	- 标签1</span><br><span class="line">	- 标签2</span><br><span class="line">	- 标签3</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><p>输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new article_name #article_name 文章名</span><br></pre></td></tr></table></figure>
<p>生成的文章文件会出现在根目录source的_posts里，打开article_name.md,在“三杠”下书写文章。三杠中的categories配置文章种类，tags配置标签；description配置文章摘要；</p>
<p>在文章中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">blog-message</span><br><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br><span class="line">blog-message</span><br></pre></td></tr></table></figure>
<p>在more之前的会被显示作为博文信息，之后会被隐藏作为Read More。</p>
<h2 id="发布到GitHub"><a href="#发布到GitHub" class="headerlink" title="发布到GitHub"></a>发布到GitHub</h2><p>安装插件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cnpm install hexo<span class="literal">-deployer</span><span class="literal">-git</span> -<span class="literal">-save</span></span><br></pre></td></tr></table></figure>
<p>同时在根目录的_config.yml的deploy配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:你的用户名/你的用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment">#默认</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo generate #将md转换为html</span><br><span class="line">hexo deploy #部署到github</span><br></pre></td></tr></table></figure>
<h2 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h2><p>​        此处以阿里云为例：</p>
<p>进入控制台</p>
<p><img src="https://i.loli.net/2020/06/04/6pEkGAqhu5wYaBd.png" alt=""></p>
<p>点击控制台-域名-域名注册，输入你想要的域名：</p>
<p>以abc-daydayenglish.cn为例</p>
<p><img src="https://i.loli.net/2020/06/04/ZaMurUs8wCS2Kj5.png" alt=""></p>
<p>完成个人信息认证并购买、认证后，设置域名。</p>
<p>进入控制台-域名-域名列表：</p>
<p>选择自己刚才购买的域名-域名解析：添加解析设置如下</p>
<p><img src="https://i.loli.net/2020/06/04/LnqDoZTy8gXS3OC.png" alt=""></p>
<p>其中github仓库ip通过cmd ping 你的github用户名.github.io获取。</p>
<p>同时设置你的项目根目录_config.yml里的url为你的域名。</p>
<p><img src="https://i.loli.net/2020/06/04/gPj4D6kpcdvyIoW.png" alt=""></p>
<p>在custom domain中输入你的域名如：xxxx.com</p>
<p>之后重新输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g d</span><br></pre></td></tr></table></figure>
<p>发布成功，更多教程见<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>英语词汇再背诵 oct-12</title>
    <url>/English/english_oct_12/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2020-10-12-单词记录"><a href="#2020-10-12-单词记录" class="headerlink" title="2020/10/12 单词记录"></a>2020/10/12 单词记录</h1><div class="table-container">
<table>
<thead>
<tr>
<th>单词</th>
<th>词性1</th>
<th>词性2</th>
<th>词性3</th>
</tr>
</thead>
<tbody>
<tr>
<td>stem</td>
<td>n.茎干</td>
<td>v.制止，阻止，起源于( + from ~)</td>
<td></td>
</tr>
<tr>
<td>successive</td>
<td>adj.连续的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sue</td>
<td>v.控告，起诉，请求</td>
<td></td>
<td></td>
</tr>
<tr>
<td>suffice</td>
<td>v.足够，使满足</td>
<td></td>
<td></td>
</tr>
<tr>
<td>superficial</td>
<td>adj.表面的，肤浅的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>superfluous</td>
<td>adj.过多的，过剩的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>triumph</td>
<td>v.取得成功</td>
<td></td>
<td></td>
</tr>
<tr>
<td>exploit</td>
<td>n.英勇事迹</td>
<td>v.开发，探测，剥削，利用</td>
<td></td>
</tr>
<tr>
<td>intellect</td>
<td>n.智力，思维逻辑</td>
<td></td>
<td></td>
</tr>
<tr>
<td>intelligible</td>
<td>adj.可理解的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>intelligence</td>
<td>n.智能，智慧，才智</td>
<td></td>
<td></td>
</tr>
<tr>
<td>intellectual</td>
<td>adj.智力的，理智的，脑力的</td>
<td>n.知识分子</td>
<td></td>
</tr>
<tr>
<td>refute</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>assimilate</td>
<td>v.同化</td>
<td></td>
<td></td>
</tr>
<tr>
<td>institute</td>
<td>n.学院，机构</td>
<td>v.建立，实施</td>
<td></td>
</tr>
<tr>
<td>humble</td>
<td>adj.谦逊的，简陋的,卑微的</td>
<td>v.贬低，低声下气，谦逊</td>
<td></td>
</tr>
<tr>
<td>bloom</td>
<td>n.花</td>
<td>v.开花，变得健康/自信</td>
<td></td>
</tr>
<tr>
<td>blow</td>
<td>n.打击，挫折</td>
<td>v.吹，刮</td>
<td></td>
</tr>
<tr>
<td>blunder</td>
<td>n.错误，过错</td>
<td>v.犯愚蠢(粗心的)的错误</td>
<td></td>
</tr>
<tr>
<td>blur</td>
<td>n.模糊</td>
<td>v.消失,模糊</td>
<td></td>
</tr>
<tr>
<td>blush</td>
<td>n.</td>
<td>v.感到尴尬或害羞,脸红</td>
<td></td>
</tr>
<tr>
<td>pray</td>
<td>v.祈祷</td>
<td>adv.请(问)</td>
<td></td>
</tr>
<tr>
<td>spectacle</td>
<td>n.精彩演出，壮丽的景象</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spectacular</td>
<td>adj.壮观的，宏伟的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>spill</td>
<td>n.洒出，摔下</td>
<td>v.洒出，溢出，蜂拥而出</td>
<td></td>
</tr>
<tr>
<td>spin</td>
<td>n.旋转，兜风</td>
<td>v.旋转，纺织</td>
<td></td>
</tr>
<tr>
<td>spiral</td>
<td>n.螺旋形</td>
<td>adj.螺旋的</td>
<td>v.螺旋上升，急剧增长</td>
</tr>
<tr>
<td>spite</td>
<td>n.怨恨</td>
<td>v.(故意)使烦恼</td>
<td></td>
</tr>
<tr>
<td>splash</td>
<td>n.迸溅声</td>
<td>v.迸溅</td>
<td></td>
</tr>
<tr>
<td>split</td>
<td>n.分歧，划分，裂口</td>
<td>v.分裂，分开，分担</td>
<td></td>
</tr>
<tr>
<td>time</td>
<td>n.时间，时期，机会</td>
<td>v.定时，调整</td>
<td></td>
</tr>
<tr>
<td>faint</td>
<td>adj.微弱的，不清楚的，微笑的</td>
<td>n.昏厥</td>
<td>v.昏厥</td>
</tr>
<tr>
<td>exotic</td>
<td>adj.外来的，新鲜的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>conquer</td>
<td>v.征服</td>
<td></td>
<td></td>
</tr>
<tr>
<td>conquest</td>
<td>n.征服</td>
<td></td>
<td></td>
</tr>
<tr>
<td>disastrous</td>
<td>adj.灾难性的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>discern</td>
<td>v.察觉出，辨别</td>
<td></td>
<td></td>
</tr>
<tr>
<td>erroneous</td>
<td>adj.错误性的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>escalate</td>
<td>v.增长</td>
<td></td>
<td></td>
</tr>
<tr>
<td>foam</td>
<td>v.起泡沫</td>
<td>n.泡沫</td>
<td></td>
</tr>
<tr>
<td>erupt</td>
<td>v.爆发</td>
<td></td>
<td></td>
</tr>
<tr>
<td>gulf</td>
<td>n.海湾，分歧</td>
<td></td>
<td></td>
</tr>
<tr>
<td>nourish</td>
<td>v.培养，滋养</td>
<td></td>
<td></td>
</tr>
<tr>
<td>novelty</td>
<td>n.新颖</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tilt</td>
<td>n.倾斜，企图</td>
<td>v.倾斜，偏向</td>
<td></td>
</tr>
<tr>
<td>weep</td>
<td>n.哭泣，落泪</td>
<td>v.哭泣</td>
<td></td>
</tr>
<tr>
<td>clumsy</td>
<td>adj.笨拙的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>cluster</td>
<td>n.簇，束</td>
<td>v.簇集，聚集</td>
<td></td>
</tr>
<tr>
<td>clutch</td>
<td>n.离合器，一群</td>
<td>v.紧握，抓紧</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>英语词汇再背诵 oct-11</title>
    <url>/English/english_oct_11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="2020-10-10-11-单词积累"><a href="#2020-10-10-11-单词积累" class="headerlink" title="2020/10/10~11 单词积累"></a>2020/10/10~11 单词积累</h1><div class="table-container">
<table>
<thead>
<tr>
<th>verdict</th>
<th>n. 判断，裁决</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>denote</td>
<td>v.标志，象征</td>
<td></td>
<td></td>
</tr>
<tr>
<td>denial</td>
<td>n. 拒绝，否认</td>
<td></td>
<td></td>
</tr>
<tr>
<td>heap</td>
<td>v.堆积，装满</td>
<td>n.堆，大量，许多</td>
<td></td>
</tr>
<tr>
<td>immerse</td>
<td>v.沉浸于，专心于</td>
<td></td>
<td></td>
</tr>
<tr>
<td>designate</td>
<td>v.指明，标明</td>
<td></td>
<td></td>
</tr>
<tr>
<td>flourish</td>
<td>v.茂盛，繁荣，兴旺</td>
<td>n.华丽辞藻，夸张动作</td>
<td></td>
</tr>
<tr>
<td>vigorous</td>
<td>adj.充满活力的，强健的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>symptom</td>
<td>n.症状，征兆</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bold</td>
<td>adj.大胆的，明显的，粗体的</td>
<td>n.黑体，粗体</td>
<td></td>
</tr>
<tr>
<td>hint</td>
<td>v.暗示，示意</td>
<td>n.暗示，建议，线索</td>
<td></td>
</tr>
<tr>
<td>impair</td>
<td>v.减少，削减</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pettion</td>
<td>n.请愿书，申请书</td>
<td></td>
<td></td>
</tr>
<tr>
<td>pierce</td>
<td>v.刺穿，看透</td>
<td></td>
<td></td>
</tr>
<tr>
<td>phenomenon</td>
<td>n.现象 (pl.phenomena)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sovereign</td>
<td>n.君主，统治</td>
<td>adj.统治的，君主的，独立自主的</td>
<td></td>
</tr>
<tr>
<td>sow</td>
<td>v.播种，传播</td>
<td></td>
<td></td>
</tr>
<tr>
<td>apt</td>
<td>adj.有…倾向的，恰当的，聪明的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>meditate</td>
<td>v.沉思，冥想</td>
<td></td>
<td></td>
</tr>
<tr>
<td>choke</td>
<td>v.窒息，抑制</td>
<td></td>
<td></td>
</tr>
<tr>
<td>despise</td>
<td>v.蔑视，鄙视</td>
<td></td>
<td></td>
</tr>
<tr>
<td>literally</td>
<td>adv.确实地，字面地</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signify</td>
<td>v.表示，预示</td>
<td></td>
<td></td>
</tr>
<tr>
<td>simplicity</td>
<td>n.简单，直率，单纯</td>
<td></td>
<td></td>
</tr>
<tr>
<td>surplus</td>
<td>adj.过剩的，剩余的</td>
<td>n.剩余，盈余</td>
<td></td>
</tr>
<tr>
<td>surpass</td>
<td>v.优于，超过</td>
<td></td>
<td></td>
</tr>
<tr>
<td>susceptible</td>
<td>adj.易受影响的，敏感的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>swarm</td>
<td>n.大量，一大批</td>
<td>v.云集，充满</td>
<td></td>
</tr>
<tr>
<td>swell</td>
<td>v.膨胀，上涨</td>
<td></td>
<td></td>
</tr>
<tr>
<td>system</td>
<td>n.系统，体系，制度</td>
<td></td>
<td></td>
</tr>
<tr>
<td>twist</td>
<td>n.扭曲，弯曲，转动</td>
<td>v.弯曲，扭动，转动</td>
<td></td>
</tr>
<tr>
<td>trival</td>
<td>adj.琐屑的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tumble</td>
<td>v.跌倒，暴跌</td>
<td>n.跌倒，骤降</td>
<td></td>
</tr>
<tr>
<td>vulgar</td>
<td>adj.庸俗的，下流的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>auxiliary</td>
<td>adj.辅助的</td>
<td></td>
<td></td>
</tr>
<tr>
<td>avail</td>
<td>v.帮助</td>
<td>n.效用，利益</td>
<td></td>
</tr>
<tr>
<td>noble</td>
<td>adj.崇高的</td>
<td>n.贵族</td>
<td></td>
</tr>
<tr>
<td>norm</td>
<td>n.规范，标准</td>
<td></td>
<td></td>
</tr>
<tr>
<td>resultant</td>
<td>adj.因由而生的</td>
<td>n.结果</td>
<td></td>
</tr>
<tr>
<td>illiterate</td>
<td>adj.没有文化的，文盲的</td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis入门案例</title>
    <url>/Java/mybatis%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="MyBatis-入门案例"><a href="#MyBatis-入门案例" class="headerlink" title="MyBatis 入门案例"></a>MyBatis 入门案例</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ol>
<li><p>Mybatis 起源:起源于Apache的ibatis项目，2010年后迁至Google 更名为Mybatis，如今迁至Git上。 </p>
</li>
<li><p>Mybatis 作用:简化传统JDBC的操作，实现数据持久化。无需通过JDBC桥梁输入sql语句来进行表的增删改查,通过ORM技术简化Dao层。</p>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>ORM :实现Java类与表的映射，直接通过修改Java类便可进行对象表的修改。</p>
</li>
<li><p>与Hibernate的联系及区别：</p>
<ul>
<li>hibernate上手难度略大于mybatis</li>
<li>hibernate拥有者优秀的映射系统，可以根据实体类生成表结构，以及HQL语言优化、简化了不少sql语句的书写；而MyBatis需要手写sql语句，复杂的sql和建立映射关系需要xml文件的配置。</li>
<li>相应的，mybatis可以做更细致的sql优化。</li>
</ul>
</li>
</ol>
<h2 id="基本配置流程"><a href="#基本配置流程" class="headerlink" title="基本配置流程"></a>基本配置流程</h2><p><img src="https://i.loli.net/2020/06/04/IEVbspFG5ZqeOc7.png" alt="mybatis period"></p>
<h3 id="配置总体文件"><a href="#配置总体文件" class="headerlink" title="配置总体文件"></a>配置总体文件</h3><p>​        于根目录下创建xml配置文件,将对应头文件字符串拷贝粘贴。其中default与id保持一致，transactionManager此处使用JDBC管理，dataSource 类型为POOL -&gt; 连接池类型。其它按照JDBC连接初始化设置。</p>
<p>​        mapper设置对应mapper的classpath字段</p>
<p>​        sqlMapConfig.xml 配置</p>
<p>​        <img src="https://i.loli.net/2020/06/04/vAtFUfbMsdN24nm.png" alt="sqlMapConfig.xml jpg"></p>
<h3 id="数据库以及实体类创建"><a href="#数据库以及实体类创建" class="headerlink" title="数据库以及实体类创建"></a>数据库以及实体类创建</h3><p>​        数据库：</p>
<p>​        <img src="https://i.loli.net/2020/06/04/wYVinCkI2M9cdhL.png" alt="User 表"></p>
<p>​        pojo:        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> u_id;</span><br><span class="line">    <span class="keyword">private</span> String u_username;</span><br><span class="line">    <span class="keyword">private</span> String u_userpassword;</span><br><span class="line">    <span class="comment">//省略get、set以及构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置映射文件"><a href="#配置映射文件" class="headerlink" title="配置映射文件"></a>配置映射文件</h3><p>​        配置xml文件,mapper下属性输入命名空间（xml路径,不带格式）,select下输入sql语句配置id,返回对象类型(之前创建,对象与表一一对应),匹配参数类型（图中案例一为int类型）,接着为标准sql查询语句（注意无分号’;’）,匹配参数:</p>
<p>​        例：u_id在案例中为int类型符合parameterType参数属性，匹配项为#{字段}(基本数据字段以及String无需与表中字段保持一致)格式。</p>
<p>​        <img src="https://i.loli.net/2020/06/04/se1IHznpJEtS267.png" alt="userMapper.xml png"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Reader reader = Resources.getResourceAsReader(<span class="string">"sqlMapConfig.xml"</span>);</span><br><span class="line">        <span class="comment">//获取SqlSessionFactory对象得到sqlSessionFactory实例</span></span><br><span class="line">        SqlSessionFactory sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);    </span><br><span class="line">    	<span class="comment">//获取“数据会话层”对象SqlSession~JDBC Cnonection对象</span></span><br><span class="line">        SqlSession session = sessionFactory.openSession();</span><br><span class="line">        <span class="comment">//mybatis会根据命名空间.id搜索对应语句</span></span><br><span class="line">        String statment = <span class="string">"com.mybatis.map.UserMapper.selAllById"</span>;</span><br><span class="line">        User user1 = session.selectOne(statment,<span class="number">1</span>);</span><br><span class="line">        User user2 = session.selectOne(statment,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(user1 == <span class="keyword">null</span> || user2 == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"error"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"success"</span>);</span><br><span class="line">            System.out.println(user1 + <span class="string">"\n"</span> + user2);</span><br><span class="line">        &#125;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数分析"><a href="#参数分析" class="headerlink" title="参数分析"></a>参数分析</h3><p>​        1）    sqlMapConfig.xml:</p>
<p>​        environment id=”test” 使用id = test 环境下的配置</p>
<p>​        environment id=”development” 使用 id = development下的配置；上级标签<environments default=".">下可使用默认id即可进行数据库用户或数据库的更换。上方代码SqlSessionFactoryBuilder的build方法的第二个参数可以指定数据库环境,如””development或者”test”</p>
<p>​    dataSource:数据源类型↓</p>
<p>①  :POOLED 使用数据库连接池类似DBCP、C3P0、druid之类管理连接池工具以及进行数据库开关。</p>
<p>②  :UNPOOLED 使用传统JDBC方式连接数据库，需手动管理。</p>
<p>③  :JNDI 从Tomcat中获取一个内置的数据库连接池</p>
<p>transactionManager type=”” 事务提交方式↓</p>
<p>1）: JDBC 使用JDBC方式 进行事务提交 。(commit rollback close)&lt;手动&gt;</p>
<p>2）: MANAGED 交给其他对象处理事务如Spring ，Jobss托管 .&lt;自动,使用后默认自动关闭连接&gt;</p>
<p>2)    Mapper.xml</p>
<p>1.namespace命名空间确定了该Mapper.xml ； 而里面语句标签的id确定了唯一一个语句，因此namespace+id确认唯一一组sql语句。</p>
<p>2.Mybatis 中 SQL语句在形式上只能有一个输入、输出参数，如上述</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="comment">#&#123;sno&#125; and sex = #&#123;#sex&#125; . </span></span><br><span class="line">如果是单一的根据sno查询，只需要将parameterType的值设置为<span class="built_in">int</span>类型即可；但是Mybatis中不允许输入多个值。解决方案是采用复杂类型进行替换如数组,<span class="keyword">List</span>,<span class="keyword">Set</span>以及pojo类等。Mybatis约定，如果输入/输出参数为<span class="number">8</span>个基本类型或者<span class="keyword">String</span>，则可使用任意占位符<span class="comment">#&#123;xxxx&#125;；如果为对象类型，则必须使用对应Java类对应字段名作为占位符参数。如果返回值是对象类型，则无论返回一个或者多个，resultType均输入其全类名（可通过设置别名简化操作）。</span></span><br></pre></td></tr></table></figure>
<p>3）mapper动态代理方式的DRUD(Mybatis接口开发)</p>
<p>原则:约定优于配置(x.java &gt; x.xml)</p>
<p>配置方式: eg : abc.xml .. </p>
<p>编码方式: eg: abc.java</p>
<p>Configuration con = new Configuration();  con.setName(“MyCon”);</p>
<p>在以上进行SQL查询时需要定义字符串String statement = “namespace.”+”id” ; ，反反复复如此操作颇为麻烦 ， 因此在此使用动态代理 (接口开发) 。 </p>
<p>创建接口，名称与对应映射文件名称一致(namespace的值与接口全类名相同),抽象方法返回值与resultType一致，形参与parameterType一致，方法名与xml中id一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法名以及返回与mapper.xml的id和param**一致</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">queryStudentById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">queryAllStudent</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteStudentById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">        Reader reader = Resources.getResourceAsReader(<span class="string">"sqlMapConfig.xml"</span>);</span><br><span class="line">        SqlSessionFactory sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);    </span><br><span class="line">        SqlSession session = sessionFactory.openSession();</span><br><span class="line">    	StudentMapper mapper = session.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    	Student stu1 = mapper.queryStudentById(<span class="number">2</span>);</span><br><span class="line">    	<span class="keyword">if</span>(stu1 != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(stu1);</span><br><span class="line">    	List&lt;Student&gt; students = mapper.queryAllStudent();</span><br><span class="line">    	<span class="keyword">if</span>(stuents != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(Student stu : students)</span><br><span class="line">                System.out.println(stu);</span><br><span class="line">        &#125;</span><br><span class="line">    	Student s = <span class="keyword">new</span> Student(<span class="string">"Jack"</span>,<span class="keyword">true</span>,<span class="number">17</span>,<span class="keyword">new</span> Date());</span><br><span class="line">    	<span class="keyword">int</span> flag = mapper.addStudent(s);</span><br><span class="line">    	<span class="keyword">if</span>(flag!=<span class="number">0</span>)</span><br><span class="line">			System.out.println(<span class="string">"add successfully"</span>);</span><br><span class="line">    	session.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="别名优化"><a href="#别名优化" class="headerlink" title="别名优化"></a>别名优化</h3><h4 id="单别名优化"><a href="#单别名优化" class="headerlink" title="单别名优化"></a>单别名优化</h4><p>​                在Mybatis总配置文件configuration标签中添加子标签<typeAliases></typeAliases>中进行别名优化，如上所述的com.mybatis.service.Student每次输入未免过于繁琐，进行如下设置可简化操作量。</p>
<p>​                <img src="https://i.loli.net/2020/06/04/3WICliSmX7MZR5B.png" alt=""></p>
<h4 id="集体优化"><a href="#集体优化" class="headerlink" title="集体优化"></a>集体优化</h4><p>​                    如上，在configuration加入子标签typeAliases下的子标签package,设置对应类的包的类路径，此时改包下的类名即别名(大小写无关)</p>
<h3 id="基本映射"><a href="#基本映射" class="headerlink" title="基本映射"></a>基本映射</h3><p>​                    <img src="https://i.loli.net/2020/06/04/i2dqyaAjWvZTLlr.png" alt=""></p>
<p>​                                                                基本关系映射</p>
<p>​                    jdbc 与 java映射</p>
<p>​            </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> JdbcType </span><br><span class="line">&#123;						<span class="comment">//&lt;-resultMap Mybatis封装枚举类型结构图</span></span><br><span class="line">	    ARRAY(<span class="number">2003</span>),</span><br><span class="line">	    BIT(-<span class="number">7</span>),</span><br><span class="line">	    TINYINT(-<span class="number">6</span>),</span><br><span class="line">	    SMALLINT(<span class="number">5</span>),</span><br><span class="line">	    INTEGER(<span class="number">4</span>),</span><br><span class="line">	    BIGINT(-<span class="number">5</span>),</span><br><span class="line">	    FLOAT(<span class="number">6</span>),</span><br><span class="line">	    REAL(<span class="number">7</span>),</span><br><span class="line">	    DOUBLE(<span class="number">8</span>),</span><br><span class="line">	    NUMERIC(<span class="number">2</span>),</span><br><span class="line">	    DECIMAL(<span class="number">3</span>),</span><br><span class="line">	    CHAR(<span class="number">1</span>),</span><br><span class="line">	    VARCHAR(<span class="number">12</span>),</span><br><span class="line">	    LONGVARCHAR(-<span class="number">1</span>),</span><br><span class="line">	    DATE(<span class="number">91</span>),</span><br><span class="line">	    TIME(<span class="number">92</span>),</span><br><span class="line">	    TIMESTAMP(<span class="number">93</span>),</span><br><span class="line">	    BINARY(-<span class="number">2</span>),</span><br><span class="line">	    VARBINARY(-<span class="number">3</span>),</span><br><span class="line">	    LONGVARBINARY(-<span class="number">4</span>),</span><br><span class="line">	    NULL(<span class="number">0</span>),</span><br><span class="line">	    OTHER(<span class="number">1111</span>),</span><br><span class="line">	    BLOB(<span class="number">2004</span>),</span><br><span class="line">	    CLOB(<span class="number">2005</span>),</span><br><span class="line">	    BOOLEAN(<span class="number">16</span>),</span><br><span class="line">	    CURSOR(-<span class="number">10</span>),</span><br><span class="line">	    UNDEFINED(-<span class="number">2147482648</span>),</span><br><span class="line">	    NVARCHAR(-<span class="number">9</span>),</span><br><span class="line">	    NCHAR(-<span class="number">15</span>),</span><br><span class="line">	    NCLOB(<span class="number">2011</span>),</span><br><span class="line">	    STRUCT(<span class="number">2002</span>),</span><br><span class="line">	    JAVA_OBJECT(<span class="number">2000</span>),</span><br><span class="line">	    DISTINCT(<span class="number">2001</span>),</span><br><span class="line">	    REF(<span class="number">2006</span>),</span><br><span class="line">	    DATALINK(<span class="number">70</span>),</span><br><span class="line">	    ROWID(-<span class="number">8</span>),</span><br><span class="line">	    LONGNVARCHAR(-<span class="number">16</span>),</span><br><span class="line">	    SQLXML(<span class="number">2009</span>),</span><br><span class="line">	    DATETIMEOFFSET(-<span class="number">155</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SQL</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-常用排序算法</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构-排序算法"><a href="#数据结构-排序算法" class="headerlink" title="数据结构 排序算法"></a>数据结构 排序算法</h1><h2 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>​                    从第一个元素开始，每次游标前进一格单位，认为左右游标范围内元素均有序；若扫描元素(已排序)大于新元素,则将此元素移                动到下个位置。</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[maxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下ArrayList均已上为准，升序排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(ArrayList &amp;<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>.arr == <span class="literal">nullptr</span> || <span class="built_in">list</span>.length &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = <span class="built_in">list</span>.arr[i];</span><br><span class="line">		<span class="keyword">int</span> k = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">list</span>.arr[k] &gt; temp)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">list</span>.arr[k + <span class="number">1</span>] = <span class="built_in">list</span>.arr[k];</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">list</span>.arr[k + <span class="number">1</span>] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>​    时间复杂度：每次循环需要判断temp以及当前元素之间的大小问题，最坏情况下需要从头到尾，因此时间复杂度为O(n<sup>2</sup>).此外，若待排序序列本身有序，则时间复杂度变为O(n).</p>
<p>​    空间复杂度：算法只用了一个临时变量temp存储临时数据，因此空间复杂度为O(1).</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>​        希尔排序为直接插入排序的改进版本，其时间复杂度根据序列划分而不同。这里使用公比为 <sup>1</sup>&frasl;<sub>2</sub> 的等比数列来划分。将长度为n的序列每次分为<sup>n</sup>/<sub>2</sub> 长度的子序列，对边界位置上的元素进行直接插入排序；接着在等分为<sup>n</sup>/<sub>4</sub> 的子序列，进行直接插入排序直到变为间隔为1的直接插入排序完成结束。</p>
<h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> [i,j] = [<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> increment = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (increment = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>); increment&gt;<span class="number">0</span>; increment = <span class="built_in">Math</span>.floor(increment/<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=increment; i&lt;len; i++) &#123;</span><br><span class="line">            j = i - increment;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; temp &lt; arr[j]) &#123;</span><br><span class="line">                arr[j + increment] = arr[j];</span><br><span class="line">                j -= increment;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><p>​                当采用等比数列(q = 0.5)时，其时间复杂度为O(nlog<sub>2</sub>n);若采用等差数列(d=2)时，时间复杂度为O(n<sup>1.5</sup>)</p>
<p>​                空间复杂度同上为O(1).</p>
<h2 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>​                        字如其名，冒泡排序使用类似与水下的泡泡不断向上浮动到水面的情形，直到没有泡泡才停止。每次比较前后两个元素，若                    大小不符，则交换。</p>
<h4 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(ArrayList &amp;<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>.arr == <span class="literal">nullptr</span> || <span class="built_in">list</span>.length &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">auto</span> swap = [](<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="built_in">list</span>.length<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>.arr[j<span class="number">-1</span>] &gt; <span class="built_in">list</span>.arr[j])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr[j<span class="number">-1</span>],arr[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><p>​                    时间复杂度为O(n<sup>2</sup>),若序列已经有序，则时间复杂度为O(n)。空间复杂度为O(1).</p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>​                        快速排序将一个序列分为两个子序列，选择一个基准，以升序为例，比起小的元素放置在其左边，大于等于他的放置在右侧                    —即分区；此操作具有递归的性质。</p>
<h4 id="算法-3"><a href="#算法-3" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++ 版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(ArrayList &amp;<span class="built_in">list</span>, <span class="keyword">int</span> ltag, <span class="keyword">int</span> rtag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ltag &gt; rtag || ltag &lt; <span class="number">0</span> || rtag &lt; <span class="number">0</span> || <span class="built_in">list</span>.arr == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (rtag &gt; <span class="built_in">list</span>.length)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="built_in">list</span>.arr[ltag];</span><br><span class="line">	<span class="keyword">int</span> i = ltag, j = rtag;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">list</span>.arr[j] &gt;= tmp)</span><br><span class="line">			j--;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">			<span class="built_in">list</span>.arr[i++] = <span class="built_in">list</span>.arr[j];</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">list</span>.arr[i] &lt; tmp)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">			<span class="built_in">list</span>.arr[j--] = <span class="built_in">list</span>.arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>.arr[i] = tmp;</span><br><span class="line">	qsort(<span class="built_in">list</span>, ltag, rtag - <span class="number">1</span>);</span><br><span class="line">	qsort(<span class="built_in">list</span>, ltag + <span class="number">1</span>, rtag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> [pivot, index] = [left, left+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=pivot;i&lt;right;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    left = (<span class="keyword">typeof</span> left == <span class="string">'number'</span> ? left : <span class="number">0</span>);</span><br><span class="line">    right = (<span class="keyword">typeof</span> right == <span class="string">'number'</span>? right : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (left  &lt; right) &#123;</span><br><span class="line">        index = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, index<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, index+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><p>​                        一般情况下快速排序的时间复杂度为O(nlog<sub>2</sub>n) , 若序列越有序，则其时间复杂度会趋于O(n<sup>2</sup>) .空间复杂度为O(log<sub>2</sub>n), 使用                    了内存栈作为递归工具。</p>
<h2 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><p>​                简单选择排序是一种较为简单直观的排序方案，每次从序列中选出一个最小（大）的元素放置进行交换即可。</p>
<h4 id="算法-4"><a href="#算法-4" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(ArrayList &amp; <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>.arr == <span class="literal">nullptr</span> || <span class="built_in">list</span>.length &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">list</span>.length; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">list</span>.arr[temp] &gt; <span class="built_in">list</span>.arr[j])</span><br><span class="line">				temp = j;</span><br><span class="line">		&#125;</span><br><span class="line">		swap&lt;<span class="keyword">int</span>&gt;(<span class="built_in">list</span>.arr[temp], <span class="built_in">list</span>.arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><p>​            时间复杂度为O(n<sup>2</sup>),空间复杂度为O(1).</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><p>​                堆是一完全二叉树，他具有完全二叉树的性质；若父结点的数据大(小)于左右孩子的数据，这样的堆称作大(小)顶堆。这里使            用顺序表来存储堆(下标从1起)。下面以构建大顶堆为例。</p>
<p>​                1. 首先对顺序表进行整理为一个大顶堆，任意非叶子结点数据值均大于其孩子结点的值。</p>
<p>​                2.  “删除”根结点，即将根结点于最后一个结点进行交换，对1~length-1 的范围内再次构建大顶堆。</p>
<p>​                3.  重复上述操作直到范围限制在根节点。</p>
<h4 id="算法-5"><a href="#算法-5" class="headerlink" title="算法"></a>算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_heap</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || low &gt; high)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; <span class="number">0</span> || high &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> i = low, j = <span class="number">2</span> * i;</span><br><span class="line">	<span class="keyword">int</span> temp = arr[low];</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (j &lt;= high &amp;&amp; arr[j] &lt; arr[j + <span class="number">1</span>])</span><br><span class="line">			j++;</span><br><span class="line">		<span class="keyword">if</span> (temp &lt; arr[j])</span><br><span class="line">		&#123;</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">			i = j;</span><br><span class="line">			j = <span class="number">2</span> * i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">		init_heap(arr, i, n);</span><br><span class="line">	<span class="keyword">for</span> (i = n; i &gt;= <span class="number">2</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		swap&lt;<span class="keyword">int</span>&gt;(arr[<span class="number">1</span>], arr[i]);</span><br><span class="line">		init_heap(arr, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h4><p>​            堆排序为不稳定排序，其时间复杂度为O(nlog<sub>2</sub>n) , 每次init_heap操作会进行一次完全二叉树的遍历，即对每一个结点的调整时间        复杂度为O(log<sub>2</sub>n) , 共需要进行n次循环，时间复杂度为O(nlog<sub>2</sub>n) .</p>
<p>​            空间复杂度为O(1).</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 列表切片的使用</title>
    <url>/Python/Slice/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Python-切片的使用"><a href="#Python-切片的使用" class="headerlink" title="Python 切片的使用"></a>Python 切片的使用</h1><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = <span class="string">'ABCDEFGH'</span></span><br><span class="line"><span class="comment">#扫描0~len(ls)</span></span><br><span class="line">print(ls[:len(ls)])</span><br><span class="line"><span class="comment">#扫描-len(ls)~-1</span></span><br><span class="line">print(ls[-len(ls):])</span><br></pre></td></tr></table></figure>
<h2 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建字符串首尾空格删除函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mytrim</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> s[:<span class="number">1</span>] == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">return</span> mytrim(s[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">-1</span>:] == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">return</span> mytrim(s[:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">'Error'</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树补充</title>
    <url>/uncategorized/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="二叉树相关的补充"><a href="#二叉树相关的补充" class="headerlink" title="二叉树相关的补充"></a>二叉树相关的补充</h1><h2 id="二叉线索树的构建以及基本遍历"><a href="#二叉线索树的构建以及基本遍历" class="headerlink" title="二叉线索树的构建以及基本遍历"></a>二叉线索树的构建以及基本遍历</h2><h3 id="中序二叉线索树的构建"><a href="#中序二叉线索树的构建" class="headerlink" title="中序二叉线索树的构建"></a>中序二叉线索树的构建</h3>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Python numpy 库的使用</title>
    <url>/Python/python%20numpy%E5%BA%93%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Python-numpy-库的使用"><a href="#Python-numpy-库的使用" class="headerlink" title="Python numpy 库的使用"></a>Python numpy 库的使用</h1><h2 id="numpy-的安装"><a href="#numpy-的安装" class="headerlink" title="numpy 的安装"></a>numpy 的安装</h2><p>​        使用pip工具-&gt; pip install numpy进行安装</p>
<a id="more"></a>
<h2 id="基本使用以及测试"><a href="#基本使用以及测试" class="headerlink" title="基本使用以及测试"></a>基本使用以及测试</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.arrange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印包含0~9数字的向量</span></span><br><span class="line">print(arr)</span><br><span class="line"></span><br><span class="line">print(type(arr))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[0 1 2 3 4 5 6 7 8 9]</span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> '<span class="attr">numpy.ndarray</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="numpy-数组创建"><a href="#numpy-数组创建" class="headerlink" title="numpy 数组创建"></a>numpy 数组创建</h2><h3 id="array-方法"><a href="#array-方法" class="headerlink" title="array 方法"></a>array 方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">-2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">-5</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dtype : 指定类型 ， ndmin : 指定维度</span></span><br><span class="line"></span><br><span class="line">b = np.array([<span class="number">3.14</span>, <span class="number">2.78</span>, <span class="number">0.89</span>], dtype=float, ndmin=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="arange-方法"><a href="#arange-方法" class="headerlink" title="arange 方法"></a>arange 方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#range(start,end,step) : [start,end)</span></span><br><span class="line">a = list(range(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">#numpy 方法 arrage(start, end, step):</span></span><br><span class="line">b = numpy.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">print(<span class="string">f'array : <span class="subst">&#123;b&#125;</span>\r, type:<span class="subst">&#123;type(b)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="创建随机数组"><a href="#创建随机数组" class="headerlink" title="创建随机数组"></a>创建随机数组</h2><h3 id="随机浮点数组random"><a href="#随机浮点数组random" class="headerlink" title="随机浮点数组random"></a>随机浮点数组random</h3><p>​        方法numpy.random.random : 产生(0,1)之间的浮点数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.random.random(size=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'array : <span class="subst">&#123;a&#125;</span>\r type :　<span class="subst">&#123;type(b)&#125;</span> '</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#产生2*3*4的随机数矩阵（3d）</span></span><br><span class="line">b = np.random.random(size = (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h3 id="随机整数数组randint"><a href="#随机整数数组randint" class="headerlink" title="随机整数数组randint"></a>随机整数数组randint</h3><p>​        方法numpy.random.randint 产生随机整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.random.randint(<span class="number">6</span>,<span class="number">12</span>,size=<span class="number">7</span>)</span><br><span class="line">print(<span class="string">f'array : <span class="subst">&#123;a&#125;</span> \r type : <span class="subst">&#123;type(a)&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成5~11的4行3列随机整数矩阵</span></span><br><span class="line">b = np.random.randint(<span class="number">5</span>,<span class="number">11</span>,size=(<span class="number">4</span>,<span class="number">3</span>))</span><br><span class="line">print(b)</span><br><span class="line">print(type(b))</span><br></pre></td></tr></table></figure>
<h3 id="获取标准正态样本"><a href="#获取标准正态样本" class="headerlink" title="获取标准正态样本"></a>获取标准正态样本</h3><p>​        方法numpy.random.randn 获取具有标准正态分布(EX=0,DX=1)的样本或样本集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.random.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>​        另外，方法numpy.random.normal获取指定期望以及方差的正态分布样本(集)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#loc : EX , scale : DX , size : 个数</span></span><br><span class="line">c = np.random.normal(loc = <span class="number">2</span>, scale = <span class="number">3</span> , size = <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h2 id="其他方法创建数组"><a href="#其他方法创建数组" class="headerlink" title="其他方法创建数组"></a>其他方法创建数组</h2><ul>
<li>numpy.zeros : 创建指定类型元素的数组(矩阵)，其余元素以0填充。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建大小为5的数组，默认为整数类型</span></span><br><span class="line">x = np.zeros(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建2*2的浮点数矩阵，填充数为0.0f</span></span><br><span class="line">y = np.zeros((<span class="number">2</span>,<span class="number">2</span>),dtype=float)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>numpy.ones:与上类似，不同的是用1进行填充。</p>
</li>
<li><p>numpy.empty:未填充，为内存初始化时的数据。</p>
</li>
<li><p>numpy.linspace:创建一个一维数组，且此数组为一个等差数列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#numpy.linspace(start, stop, num, endpoint)</span></span><br><span class="line"><span class="string">'''start:begin, stop:end, num:个数, endpoint表示该值是否包含在数列：默认为True'''</span></span><br><span class="line"><span class="comment">#endpoint=True,step = (stop-start)/num; endpoint=False, step=(stop-start)/(num-1).</span></span><br><span class="line">x = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">#[10.  12.5 15.  17.5 20. ]</span></span><br><span class="line"></span><br><span class="line">y = np.linspace(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#[10. 12. 14. 16. 18.]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>numpy.logspace:创建一个以为数组，此数组为一等比数列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">numpy.logspace(start, stop, num, ,endpoint, base)</span></span><br><span class="line"><span class="string">start: 序列起始值; stop: 序列终止值;</span></span><br><span class="line"><span class="string">num: 生成等步长的样本数量，默认10</span></span><br><span class="line"><span class="string">base: 对数log的底数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">f = np.logspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">5</span>, endpoint=<span class="literal">False</span>, base=<span class="number">2</span>, dtype=np.int)</span><br><span class="line">print(f)</span><br><span class="line"><span class="comment">#[  1   4  16  64 256]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ndarray-对象字段及其方法"><a href="#ndarray-对象字段及其方法" class="headerlink" title="ndarray 对象字段及其方法"></a>ndarray 对象字段及其方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>field</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>ndarray.ndim</td>
<td>秩，轴的数量或维度数量</td>
</tr>
<tr>
<td>ndarray.shape</td>
<td>数组维度；若为矩阵则表示n行m列(返回元组)</td>
</tr>
<tr>
<td>ndarray.size</td>
<td>数组元素的总个数 = n*m</td>
</tr>
<tr>
<td>ndarray.dtype</td>
<td>ndarray对象元素类型</td>
</tr>
<tr>
<td>ndarray.itemsize</td>
<td>对象每个元素的大小(byte)</td>
</tr>
<tr>
<td>ndarray.flags</td>
<td>对象的内存信息</td>
</tr>
<tr>
<td>ndarray.real</td>
<td>ndarray元素的实部</td>
</tr>
<tr>
<td>ndarray.imag</td>
<td>ndarray元素的虚部</td>
</tr>
</tbody>
</table>
</div>
<h2 id="矩阵相关"><a href="#矩阵相关" class="headerlink" title="矩阵相关"></a>矩阵相关</h2><h3 id="矩阵切片以及索引"><a href="#矩阵切片以及索引" class="headerlink" title="矩阵切片以及索引"></a>矩阵切片以及索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">1</span>, <span class="number">13</span>)</span><br><span class="line"><span class="comment">#将一维数组a分解为3*4的矩阵</span></span><br><span class="line">x = a.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[ 1  2  3  4]</span></span><br><span class="line"><span class="string"> [ 5  6  7  8]</span></span><br><span class="line"><span class="string"> [ 9 10 11 12]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#获取第2个行向量</span></span><br><span class="line">print(h[<span class="number">1</span>])</span><br><span class="line"><span class="comment">#获取第1个列向量</span></span><br><span class="line">print(h[:, <span class="number">0</span>])</span><br><span class="line"><span class="comment">#获得全行全列</span></span><br><span class="line">print(h[:, :])</span><br><span class="line"><span class="comment">#获取第3行第4列的元素(第二为坐标形式)</span></span><br><span class="line">print(h[<span class="number">2</span>][<span class="number">3</span>])</span><br><span class="line">print(h[<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">#获取第2行第3列以及第1行第2列元素(坐标):第一个元组为行标，第二个为列标</span></span><br><span class="line">print(h[(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>)])</span><br><span class="line"><span class="comment">#获取2阶顺序主子矩阵(即获取前两行，前两列的子矩阵)</span></span><br><span class="line">print(h[:<span class="number">2</span>, :<span class="number">2</span>])</span><br><span class="line"><span class="comment">#获取前3行，前2列的子矩阵</span></span><br><span class="line">print(h[<span class="number">0</span>:<span class="number">3</span>, :<span class="number">2</span>])</span><br><span class="line"><span class="comment">#获取偶数列，奇数行的子矩阵</span></span><br><span class="line">print(h[::<span class="number">2</span>, <span class="number">1</span>::<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h3 id="数组-矩阵-的复制"><a href="#数组-矩阵-的复制" class="headerlink" title="数组(矩阵)的复制"></a>数组(矩阵)的复制</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.arange(<span class="number">1</span>, <span class="number">13</span>)</span><br><span class="line">mat = arr.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(mat[:, :])</span><br><span class="line">print(arr)</span><br><span class="line">tmp = np.copy(h[:, :<span class="number">1</span>])</span><br><span class="line">mat[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">print(mat[:, :<span class="number">1</span>])</span><br><span class="line">print(id(g[<span class="number">0</span>]),id(h[<span class="number">0</span>, <span class="number">0</span>]))</span><br><span class="line">print(id(tmp[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 1  2  3  4]</span></span><br><span class="line"><span class="string"> [ 5  6  7  8]</span></span><br><span class="line"><span class="string"> [ 9 10 11 12]]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> [ 1  2  3  4  5  6  7  8  9 10 11 12]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> [[-1]</span></span><br><span class="line"><span class="string"> [ 5]</span></span><br><span class="line"><span class="string"> [ 9]]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> [[1]</span></span><br><span class="line"><span class="string"> [5]</span></span><br><span class="line"><span class="string"> [9]]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> 2199594134072 2199594134072</span></span><br><span class="line"><span class="string"> 2199602709728</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>​        可得出数组(矩阵)切片得出的子数组(矩阵)的实现方式为浅拷贝， 实际上子数组对于数值的内存地址与对应父数组的地址相同。</p>
<p>​        若不想得到这样的结果，可使用numpy的copy方法实现深拷贝。如上可知切片化的子数组内存与父数组不同。</p>
<h3 id="数组的升维以及降维的修改"><a href="#数组的升维以及降维的修改" class="headerlink" title="数组的升维以及降维的修改"></a>数组的升维以及降维的修改</h3><ul>
<li><p>reshape(row, col)</p>
<p>   参数为row, col或者元组(row, col),对于三维则输入3维向量为参数。</p>
<ol>
<li><p>numpy.reshape</p>
<p>​    为numpy的静态方法:reshape(arr,(a,b,)) : 参数1为源数组，参数2为元组(维度分割)</p>
<p>numpy.reshape(size)</p>
<p>​    对矩阵进行降维；size为元素个数，若size为-1，则表示所有元素。</p>
</li>
</ol>
</li>
<li><p>ravel</p>
<p>将多维数组转换为一维数组。</p>
</li>
</ul>
<h2 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h2><h4 id="水平拼接"><a href="#水平拼接" class="headerlink" title="水平拼接"></a>水平拼接</h4><p>​        使用hstack方法可将多个数组进行拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">l1 = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=<span class="number">12</span>)</span><br><span class="line">l2 = np.random.randint(<span class="number">0</span>, <span class="number">8</span>, size=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">ll1 = np.reshape(l1, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">ll2 = np.reshape(l2, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">ls1 = np.hstack([l1, l2])</span><br><span class="line">ls2 = np.hstack([ll1, ll2])</span><br><span class="line"></span><br><span class="line">print(ls1)</span><br><span class="line">print(ls2)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[0 3 4 3 8 5 1 9 4 3 0 5 2 1 6 2 0 0 6 6 2]</span></span><br><span class="line"><span class="string">[[0 3 4 3 2 1 6]</span></span><br><span class="line"><span class="string"> [8 5 1 9 2 0 0]</span></span><br><span class="line"><span class="string"> [4 3 0 5 6 6 2]]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="垂直拼接"><a href="#垂直拼接" class="headerlink" title="垂直拼接"></a>垂直拼接</h4><p>​        使用vstack方法进行多个数组的拼接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">l1 = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=<span class="number">12</span>)</span><br><span class="line">l2 = np.random.randint(<span class="number">0</span>, <span class="number">8</span>, size=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">ll1 = np.reshape(l1, (<span class="number">4</span>, <span class="number">3</span>))</span><br><span class="line">ll2 = np.reshape(l2, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">ls = np.vstack([ll1, ll2])</span><br><span class="line"></span><br><span class="line">print(ls)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[0 7 4]</span></span><br><span class="line"><span class="string"> [7 6 9]</span></span><br><span class="line"><span class="string"> [8 2 3]</span></span><br><span class="line"><span class="string"> [2 0 7]]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">[[1 6 0]</span></span><br><span class="line"><span class="string"> [6 4 6]</span></span><br><span class="line"><span class="string"> [5 0 2]]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">[[0 7 4]</span></span><br><span class="line"><span class="string"> [7 6 9]</span></span><br><span class="line"><span class="string"> [8 2 3]</span></span><br><span class="line"><span class="string"> [2 0 7]</span></span><br><span class="line"><span class="string"> [1 6 0]</span></span><br><span class="line"><span class="string"> [6 4 6]</span></span><br><span class="line"><span class="string"> [5 0 2]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p>​        concatenate方法可进行水平或者垂直拼接：numpy.concatenate(array1,array2,axis=0),默认asix=0为垂直拼接,axis = 1则为水瓶拼接。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%A4%8D%E4%B9%A0%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构顺序表-链表"><a href="#数据结构顺序表-链表" class="headerlink" title="数据结构顺序表-链表"></a>数据结构顺序表-链表</h1><h2 id="概述与基本逻辑结构"><a href="#概述与基本逻辑结构" class="headerlink" title="概述与基本逻辑结构"></a>概述与基本逻辑结构</h2><p>​        链表是线性表的一种链式构成；与顺序表不同，链表元素在内存单元中并非全是连续存储的。顺序表的一大优点是随机访问，在访问元素的速度比链表快。相反的，顺序表的缺点便是链表的优点；链表在插入、删除元素方面比顺序表快，并且理论上链表的存储空间是可以无限扩增的。</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>​        链式存储结构的结点最基本结构即以下：数据域+指针域。每个元素只有一个前驱元素以及一个后继元素，每个节点的指针域保存者指向下一个节点的指针；数据域的数据可以是简单的1,2,3等数字，也可以是Student，Book等结构体或者类。这种单链表结构又可以根据有无头结点分类。头结点的指针指向链表第一个节点，头结点的数据域可为空；每次访问链表需从头结点开始遍历表中每一个元素,head结点作为入口存在标志着一个链表的存在。</p>
<p><img src="https://i.loli.net/2020/06/10/SFDq5kmJM3GZteK.png" alt="单链表.png"></p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>​        双向链表在单链表的基础上增添了指向前一个结点的指针域，该结构相较于普通的单链表结构可以双向访问结点而非“一路走到黑”。包括双向链表，以下结构均可根据有无头结点进行分类，以下均以有头结点为例不在阐述。</p>
<p><img src="https://i.loli.net/2020/06/10/nfz72oEjXqpVSRI.png" alt="双向链表.png"></p>
<h3 id="单向循环链表"><a href="#单向循环链表" class="headerlink" title="单向循环链表"></a>单向循环链表</h3><p>​        单向链表的基础上进行改装，将尾结点的指针域指向头结点即可。若不含头结点，则直接指向首个结点。</p>
<p>​        </p>
<h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p>​        在双向链表上进行改装，将最后一个节点的后指针域指向头结点，头结点的前指针域指向尾结点。</p>
<p><img src="https://i.loli.net/2020/06/10/t8MpfTlNFwouse1.png" alt="双循环链表.png"></p>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>​        如Java, python , javascript等无指针的语言使用静态链表（静态双链表同理）。这种表结构可视作’’索引表’’。</p>
<h2 id="存储结构的实现"><a href="#存储结构的实现" class="headerlink" title="存储结构的实现"></a>存储结构的实现</h2><p>​        单链表结点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;	<span class="comment">//数据域：储存数据</span></span><br><span class="line">    LNode *next;	<span class="comment">//指针域：指向下一个结点</span></span><br><span class="line">&#125;lNode;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<p>​    双链表节点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;	<span class="comment">//数据域</span></span><br><span class="line">    dNode *next;	<span class="comment">//后指针域：指向下一个结点</span></span><br><span class="line">    dNode *prior;	<span class="comment">//前指针域：指向前一个结点</span></span><br><span class="line">&#125;dNode;</span><br></pre></td></tr></table></figure>
<p>​    静态链表:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxLength 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> data; <span class="comment">//数据</span></span><br><span class="line">  <span class="keyword">int</span> next; <span class="comment">//下一个结点的索引</span></span><br><span class="line">&#125;sNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linkList</span>&#123;</span></span><br><span class="line">    linkNode node[maxLength]; <span class="comment">//存储体</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">//当前长度</span></span><br><span class="line">&#125;sList;</span><br></pre></td></tr></table></figure>
<h2 id="单链表基本操作"><a href="#单链表基本操作" class="headerlink" title="单链表基本操作"></a>单链表基本操作</h2><h3 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LNode *node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若有头结点，则参数为node-&gt;next</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> getLength(node-&gt;next) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="释放空间"><a href="#释放空间" class="headerlink" title="释放空间"></a>释放空间</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(LNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	LNode *tmp = node;</span><br><span class="line">	<span class="keyword">while</span> (tmp != <span class="literal">nullptr</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		LNode *cur = tmp;</span><br><span class="line">		tmp = tmp-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayList</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node *tmp = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tmp!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,tmp-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertBack</span><span class="params">(LNode * head, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *tmp = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (tmp-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">		tmp = tmp-&gt;next;</span><br><span class="line">	LNode *tail = <span class="keyword">new</span> LNode;</span><br><span class="line">	tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	tail-&gt;data = elem;</span><br><span class="line">	tmp-&gt;next = tail;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertFront</span><span class="params">(LNode * head, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode *tmp = <span class="keyword">new</span> LNode;</span><br><span class="line">	tmp-&gt;data = elem;</span><br><span class="line">	tmp-&gt;next = head-&gt;next;</span><br><span class="line">	head-&gt;next = tmp;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普遍插入"><a href="#普遍插入" class="headerlink" title="普遍插入"></a>普遍插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertMiddle</span><span class="params">(LNode * head, <span class="keyword">int</span> location , <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (location &lt;= <span class="number">0</span> || location &gt; getLength(head-&gt;next))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">	LNode *tmp = head;</span><br><span class="line">	<span class="keyword">while</span> (index &lt; location)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = tmp-&gt;next;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *neo = <span class="keyword">new</span> LNode;</span><br><span class="line">	neo-&gt;data = elem;</span><br><span class="line">	neo-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	neo-&gt;next = tmp-&gt;next;</span><br><span class="line">	tmp-&gt;next = neo;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteByIndex</span><span class="params">(LNode *head,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *tmp = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index<span class="number">-1</span>;i++)</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    LNode *targer = tmp-&gt;next;</span><br><span class="line">    tmp = target-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除所有相同元素"><a href="#删除所有相同元素" class="headerlink" title="删除所有相同元素"></a>删除所有相同元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteSameData</span><span class="params">(LNode * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	LNode *p, *q, *r;</span><br><span class="line">	p = head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		q = p;</span><br><span class="line">		<span class="keyword">while</span> (q-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;next-&gt;data == p-&gt;data)</span><br><span class="line">			&#123;</span><br><span class="line">				r = q-&gt;next;</span><br><span class="line">				q-&gt;next = r-&gt;next;</span><br><span class="line">				<span class="keyword">delete</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				q = q-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取元素首次出现位置"><a href="#获取元素首次出现位置" class="headerlink" title="获取元素首次出现位置"></a>获取元素首次出现位置</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getElemFirstLocation</span><span class="params">(LNode * head, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	LNode *p = head;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span> &amp;&amp; p-&gt;next-&gt;data != elem) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (index + <span class="number">1</span> &gt;= getLength(head-&gt;next))</span><br><span class="line">		<span class="keyword">return</span> NOT_FOUND;</span><br><span class="line">	<span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆置"><a href="#逆置" class="headerlink" title="逆置"></a>逆置</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseNodeList</span><span class="params">(LNode * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LNode *p, *q;</span><br><span class="line">	p = head-&gt;next;</span><br><span class="line">	head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q-&gt;next = head-&gt;next;</span><br><span class="line">		head-&gt;next = q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaximum</span><span class="params">(LNode * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	LNode *p = head-&gt;next,*q;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">max</span> = p-&gt;data;</span><br><span class="line">	q = p;</span><br><span class="line">	<span class="keyword">while</span> (q!=<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		q = p-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (q == <span class="literal">nullptr</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (q-&gt;data &gt; p-&gt;data)</span><br><span class="line">			<span class="built_in">max</span> = q-&gt;data;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举体-Status"><a href="#枚举体-Status" class="headerlink" title="枚举体 Status"></a>枚举体 Status</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status</span><br><span class="line">&#123;</span><br><span class="line">	ERROR = <span class="number">-2</span>,</span><br><span class="line">	NOT_FOUND = <span class="number">-1</span> ,</span><br><span class="line">	SUCCESS = <span class="number">0</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树探索(一)</title>
    <url>/C/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="树相关"><a href="#树相关" class="headerlink" title="树相关"></a>树相关</h1><h2 id="树及其定义"><a href="#树及其定义" class="headerlink" title="树及其定义"></a>树及其定义</h2><p>​                树是一种非线性数据结构，用关系的观点来看便是同种数据类型的一对多关系。树是由唯一的根结点与其互不相交的子结点-子树组成；而每一子树也是一颗树，此节点亦可以作为根节点，拥有着子树；因此可看出树的定义具有递归性。注意的是，树的结点数目可以为空(此时称为空树)，同线性表以及串，而图禁止为空(树可视作特殊的图)。</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul>
<li><p>结点    ：如下图的A~G均为结点，若对结点再分类可有子孙、孩子、双亲、叶子结点等。</p>
</li>
<li><p>结点的度 ：当前结点所拥有子树个数或者分支个数。如D的度为1，B的度为0.</p>
</li>
<li><p>树的度：数中结点的最大值，如下方树的度为 3 (A:3).</p>
</li>
<li><p>叶子结点：度为0的结点，如B、G、F、E。</p>
</li>
<li><p>孩子结点：当前结点所属子结点，如A的孩子有B、C、D。</p>
</li>
<li><p>双亲结点：当前结点的直属根节点，如G的双亲结点为D。</p>
</li>
<li><p>祖先结点：从根节点到某结点路径上所有结点均为此根的子孙，而这些结点的祖先结点便是此根。</p>
</li>
<li><p>兄弟结点：与当前结点拥有同一直属根节点，如B、C、D均为A的孩子 结点，均为兄弟结点。</p>
</li>
<li><p>堂兄弟结点：同一层次但双亲结点不同的结点，如E与G。</p>
</li>
<li><p>有序树与无序树：树中结点的子树从左到右是有次序的不可交换</p>
</li>
<li><p>子孙结点：上述已经阐述。</p>
</li>
<li><p>层次：从根结点开始计算为第一层，其孩子结点为第二层，孩子结点的孩子结点为第三层，以此类推。</p>
</li>
<li><p>高度：亦可称为深度(有些书持有不同观点，高度为自根结点到该结点对应的层次，深度则为该结点对应对大层次的子孙结点与其之间的层次差，我这里将二者概念视为相同)</p>
</li>
<li><p>森林：若干个互不相交的树组成的集合。下方树将根节点A去掉，剩下的{B},{C,E,F},{D,G}为三颗树，组成一森林。</p>
</li>
<li><p>二叉树：度最大值为2，子树具有左右顺序之分的树</p>
</li>
</ul>
<p>​    <img src="https://i.loli.net/2020/06/30/RNPgzwOAKSp1UH4.png" alt=""></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>​                1. 非空二叉树其叶子结点的数量为其双分支结点的数量减一。</p>
<p>​                2. 对于任意树。其总分支数等于总结点数减一。        </p>
<p>​                3. 给定n个结点，所能构成二叉树的个数N为</p>
<script type="math/tex; mode=display">
N = \frac{C_{2n}^{n}\textrm{}}{n+1}</script><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>​                            若一颗二叉树除了最下方一层所有节点的度为2，则这样的二叉树称为满二叉树。</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​                                            在一颗满二叉树的基础下对最下方一层的结点选择性删除，留下至少一个结点，则这样的二叉树称为完全二叉                                    树；若将此最后一个结点删除，则又会得到一个满二叉树。</p>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p>​                                            具有n个结点的完全二叉树若从根节点开始以1开始从上到下、从左到右编号，编号完成的结点具有以下性质,若                                    当前结点编号为</p>
<p>​                                            1.若k!=1,则其双亲结点的编号为RoundDown(n/2)[即向下取整n/2]</p>
<p>​                                            2. 若2<em>k&lt;=n,则其左孩子编号为2</em>k;若2<em>k+1&lt;=n 右孩子编号为2</em>k+1</p>
<p>​                                            3. 具有n个结点的二叉树的高度h为</p>
<p>​                            </p>
<script type="math/tex; mode=display">
h = \left \lfloor log_{2}{n} \right \rfloor + 1 = \left \lceil log_{2}{(n+1)} \right \rceil</script><h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>​                    顺序存储结构使用一个数组来存放一颗二叉树，一般结点数较少或者完全二叉树适合使用。若存储完全二叉树，则需要空出下            标为0的位置，从1开始存储结点；为避免空间浪费，可使用该位置结点存放此二叉树的结点数信息或者高度、层、度数等。</p>
<h4 id="完全二叉树的顺序存储"><a href="#完全二叉树的顺序存储" class="headerlink" title="完全二叉树的顺序存储"></a>完全二叉树的顺序存储</h4><p>​                    正如上文所述，完全二叉树或满二叉树可以使用顺序存储的方式进行存储，存储结构使用数组即可，注意首个元素存储下标从1开始。基本操作如下：</p>
<p>​                    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前结点node[k],长度为n;</span></span><br><span class="line"><span class="comment">//访问左孩子, 若2k &lt;= n</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,node[<span class="number">2</span>*k]);</span><br><span class="line"><span class="comment">//访问右孩子，若2k+1&lt;=n</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,node[<span class="number">2</span>*k+<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//访问父结点，若k!=1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,node[<span class="keyword">int</span>(k/<span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//前序遍历,以下index&gt;=1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(<span class="keyword">int</span> *node,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index &gt; <span class="keyword">sizeof</span>(node)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="keyword">sizeof</span>(node)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,node[index]);</span><br><span class="line">        preOrderTraverse(node, <span class="number">2</span>*index);</span><br><span class="line">        preOrderTraverse(node, <span class="number">2</span>*index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">infixOrderTraverse</span><span class="params">(<span class="keyword">int</span> *node,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index &gt; <span class="keyword">sizeof</span>(node)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="keyword">sizeof</span>(node)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        preOrderTraverse(node, <span class="number">2</span>*index);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,node[index]);</span><br><span class="line">        preOrderTraverse(node, <span class="number">2</span>*index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(<span class="keyword">int</span> *node,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">1</span>||index &gt; <span class="keyword">sizeof</span>(node)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="keyword">sizeof</span>(node)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        preOrderTraverse(node, <span class="number">2</span>*index);</span><br><span class="line">        preOrderTraverse(node, <span class="number">2</span>*index+<span class="number">1</span>);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d "</span>,node[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>​                    链式存储的范围大于前者，在空间上更好展示其结构性。如下结构体定义一颗二叉树的结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    elemType data; <span class="comment">//elemType为一个泛类型，代表抽象数据类型</span></span><br><span class="line">    BTNode *lchild;</span><br><span class="line">    BTNode *rchild;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>
<h4 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinNode *<span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BinNode *tmp;</span><br><span class="line">	<span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;data);</span><br><span class="line">	<span class="keyword">if</span> (data != <span class="number">-1</span>) <span class="comment">//这里以-1作为终止符号， 采用先序遍历的方式初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		tmp = <span class="keyword">new</span> BinNode;</span><br><span class="line">		tmp-&gt;data = data;</span><br><span class="line">		tmp-&gt;lchild = init();</span><br><span class="line">		tmp-&gt;rchild = init();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tmp = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历相关"><a href="#遍历相关" class="headerlink" title="遍历相关"></a>遍历相关</h5><h6 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(node);</span><br><span class="line">        preOrderTraverse(node-&gt;lchild);</span><br><span class="line">        preOrderTraverse(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">infixOrderTraverse</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        infixOrderTraverse(node-&gt;lchild);</span><br><span class="line">        visit(node);</span><br><span class="line">        infixOrderTraverse(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrderTraverse(node-&gt;lchild);</span><br><span class="line">        postOrderTraverse(node-&gt;rchild);</span><br><span class="line">        visit(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h6 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为方便一下使用c++ stl库的queue以及stack进行辅助</span></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arrOrderTraverse</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    BTNode *tmp = node;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BTNode*&gt; que;</span><br><span class="line">    que.push(node);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        visit(tmp);</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;lchild!=<span class="literal">nullptr</span>)</span><br><span class="line">            que.push(tmp-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;rchild!=<span class="literal">nullptr</span>)</span><br><span class="line">            que.push(tmp-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BTNode*&gt; s;</span><br><span class="line">    s.push(node);</span><br><span class="line">    BTNode *tmp;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        visit(tmp);</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;rchild!=<span class="literal">nullptr</span>)</span><br><span class="line">            s.push(tmp-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;lchild!=<span class="literal">nullptr</span>)</span><br><span class="line">            s.push(tmp-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">infixOrderTraverse</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BTNode*&gt; s;</span><br><span class="line">    BTNode *tmp = node;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty() || tmp!= <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(tmp);</span><br><span class="line">            tmp = tmp-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            visit(tmp);</span><br><span class="line">            tmp = tmp-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BTNode*&gt; s1,s2;</span><br><span class="line">    s1.push(node);</span><br><span class="line">    BTNode *tmp = node;</span><br><span class="line">    <span class="keyword">while</span>(!s1.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = s1.top();</span><br><span class="line">        s1.pop();</span><br><span class="line">        s2.push(tmp);</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;lchild!=<span class="literal">nullptr</span>)</span><br><span class="line">            s1.push(tmp-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;rchild!=<span class="literal">nullptr</span>)</span><br><span class="line">            s1.push(tmp-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        visit(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取高度"><a href="#获取高度" class="headerlink" title="获取高度"></a>获取高度</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTreeHeight</span><span class="params">(BinNode * node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> a = getTreeDegree(node-&gt;lchild);</span><br><span class="line">	<span class="keyword">int</span> b = getTreeDegree(node-&gt;rchild);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>&lt;<span class="keyword">int</span>&gt;(a, b) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取叶子节点个数"><a href="#获取叶子节点个数" class="headerlink" title="获取叶子节点个数"></a>获取叶子节点个数</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLeafNodeCount</span><span class="params">(BTNode *node, <span class="keyword">int</span> &amp;count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        getLeafNodeCount(node-&gt;lchild, count);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;lchild==<span class="literal">nullptr</span> &amp;&amp; node-&gt;rchild==<span class="literal">nullptr</span>)</span><br><span class="line">            count++;</span><br><span class="line">        getLeafNodeCount(node-&gt;rchild, count);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉搜索"><a href="#二叉搜索" class="headerlink" title="二叉搜索"></a>二叉搜索</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">binarySearch</span><span class="params">(BTNode *node, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;data == target)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        binarySearch(node-&gt;lchild, target);</span><br><span class="line">        binarySearch(node-&gt;rchild; target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="交换二叉树的左右子树"><a href="#交换二叉树的左右子树" class="headerlink" title="交换二叉树的左右子树"></a>交换二叉树的左右子树</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExchangeBTNode</span><span class="params">(BinNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		BinNode *tmp;</span><br><span class="line">		ExchangeBTNode(tmp-&gt;lchild);</span><br><span class="line">		ExchangeBTNode(tmp-&gt;rchild);</span><br><span class="line">		tmp = node-&gt;lchild;</span><br><span class="line">		node-&gt;lchild = node-&gt;rchild;</span><br><span class="line">		node-&gt;rchild = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断一棵树是否为完全二叉树"><a href="#判断一棵树是否为完全二叉树" class="headerlink" title="判断一棵树是否为完全二叉树"></a>判断一棵树是否为完全二叉树</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCompleteBTNodeTree</span><span class="params">(BinNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">queue</span>&lt;BinNode*&gt; que;</span><br><span class="line">		que.push(node);</span><br><span class="line">		BinNode *tmp;</span><br><span class="line">		<span class="keyword">while</span> (!que.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			tmp = que.front();</span><br><span class="line">			que.pop();</span><br><span class="line">			<span class="keyword">if</span> (tmp != <span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				que.push(tmp-&gt;lchild);</span><br><span class="line">				que.push(tmp-&gt;rchild);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span> (que.empty())</span><br><span class="line">				&#123;</span><br><span class="line">					tmp = que.front();</span><br><span class="line">					que.pop();</span><br><span class="line">					<span class="keyword">if</span> (tmp != <span class="literal">nullptr</span>)</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shift</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> <span class="built_in">height</span>)</span>	<span class="comment">//此处的arr数组为完全二叉树的顺序存储模式， 下标从1开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = <span class="number">2</span> * i;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span> (j&lt;high &amp;&amp; arr[j] &lt; arr[j+<span class="number">1</span>])</span><br><span class="line">            ++j;</span><br><span class="line">        <span class="keyword">if</span> (tmp &lt; arr[j])</span><br><span class="line">        &#123;</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,tmp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="keyword">int</span>(n/<span class="number">2</span>);i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        shift(arr, i, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;=<span class="number">2</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = arr[i];</span><br><span class="line">        arr[<span class="number">1</span>] = arr[i];</span><br><span class="line">        arr[i] = tmp;</span><br><span class="line">        shift(arr,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之顺序表</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="数据结构线性表复习之顺序表"><a href="#数据结构线性表复习之顺序表" class="headerlink" title="数据结构线性表复习之顺序表"></a>数据结构线性表复习之顺序表</h1><h2 id="静态实现"><a href="#静态实现" class="headerlink" title="静态实现"></a>静态实现</h2><p>​        以静态的数组形式存放数据，连续的存储空间，高存储密度以及支持随机存取；由于静态，最大存储空间被锁死，无法进行拓展。</p>
<p>​        代码：（C++ 实现）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxLength 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinearList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> arr[maxLength];</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<h2 id="动态实现"><a href="#动态实现" class="headerlink" title="动态实现"></a>动态实现</h2><p>​        使用动态创建存储空间进行存储。</p>
<p>​        代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DynamicList</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *arr; <span class="comment">//数组指针</span></span><br><span class="line">    <span class="keyword">int</span> capacity; <span class="comment">//总容量</span></span><br><span class="line">    <span class="keyword">int</span> length;	<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqlList;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><p>​        以下操作均以静态表为例，指出了顺序表的常见操作。</p>
<h3 id="判断是否为空、满"><a href="#判断是否为空、满" class="headerlink" title="判断是否为空、满"></a>判断是否为空、满</h3><p>​        线性表判断是否有效根据当前长度与最大容量进行比较即可，即上界以及下界的比较</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInValid</span><span class="params">(LinearList <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinearList <span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">//判断是否为满</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(LinearList <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInValid</span><span class="params">(LinearList <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>.length &lt; <span class="number">0</span> || <span class="built_in">list</span>.length &gt; maxLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinearList <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(LinearList <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>.length==maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>​        顺序表在插入时需要保证未发生越界情况；若插入位置在表尾，则可以直接插入，此时的时间效率为O(1)(理想状况)；若考虑最坏情况，在表头插入元素，则需要移动n-1个元素；一般情况，每个元素被插入具有等可能性，n个元素的情况下，每个元素位置被插入的概率为1/n+1,则其分布律(矩阵形式)如下：</p>
<p>​<br><img src="https://i.loli.net/2020/06/02/idAntxqUVfwuCgv.png" alt=""><br>​<br>数学期望：<br><img src="https://i.loli.net/2020/06/02/321THrz8OfjyVBg.png" alt=""><br>​即其时间复杂度为O(n)<br><img src="https://i.loli.net/2020/06/02/ARPcWL7pK8jQSEi.png" alt=""></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>​            </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertElementBack</span><span class="params">(LinearList &amp;<span class="built_in">list</span>, <span class="keyword">int</span> target)</span></span>;</span><br><span class="line"><span class="comment">//中插法插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertElementFront</span><span class="params">(LinearList &amp;<span class="built_in">list</span>, <span class="keyword">int</span> index, <span class="keyword">int</span> elem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertElementBack</span><span class="params">(LinearList &amp; <span class="built_in">list</span>, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isFull(<span class="built_in">list</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>.arr[<span class="built_in">list</span>.length++] = target;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertElementFront</span><span class="params">(LinearList &amp; <span class="built_in">list</span>, <span class="keyword">int</span> index, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isFull(<span class="built_in">list</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; maxLength || index &gt; <span class="built_in">list</span>.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">size_t</span> i = <span class="built_in">list</span>.length;</span><br><span class="line">	<span class="keyword">for</span> (; i &gt; index - <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">list</span>.arr[i] = <span class="built_in">list</span>.arr[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>.arr[i] = elem;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>​        删除元素可根据下标或者元素值进行删除，类似的，需要保证下标访问越界的问题不触发。</p>
<p>​        最优情况为删除尾部元素，时间复杂度为O(1);最坏情况为删除头部元素，需要移动n-1个元素；平均情况每个元素被删除具有等可能性，概率为1/n.若设X为移动的元素下标数，则其期望为EX = （1+n）/2 , 时间复杂度为O(n).</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据元素删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteElement</span><span class="params">(LinearList &amp; <span class="built_in">list</span>, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>.arr[i] == target)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> k = i; k &lt; <span class="built_in">list</span>.length; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">list</span>.arr[i] = <span class="built_in">list</span>.arr[i + <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除重复(覆盖)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteAllElement</span><span class="params">(LinearList &amp; <span class="built_in">list</span>, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>.arr[i] != target)</span><br><span class="line">		&#123;</span><br><span class="line">			k++;</span><br><span class="line">			<span class="built_in">list</span>.arr[k] = <span class="built_in">list</span>.arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">list</span>.length = k + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据下标删除，返回有待修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteElementByIndex</span><span class="params">(LinearList &amp; <span class="built_in">list</span>, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isEmpty(<span class="built_in">list</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-666</span>;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; maxLength || index &gt; <span class="built_in">list</span>.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-666</span>;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="built_in">list</span>.arr[index];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = index - <span class="number">1</span>; i &lt; <span class="built_in">list</span>.length; i++) &#123;</span><br><span class="line">		<span class="built_in">list</span>.arr[i] = <span class="built_in">list</span>.arr[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>​        此处的查找时最简单的蛮力法进行检索，其他更高效率的检索方案会在后面算法篇章进行介绍。</p>
<p>​        </p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>​        </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据元素获取下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locateElement</span><span class="params">(LinearList <span class="built_in">list</span>, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>.arr[i] == target)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="考试相关"><a href="#考试相关" class="headerlink" title="考试相关"></a>考试相关</h2><h3 id="题型一-顺序表的逆置"><a href="#题型一-顺序表的逆置" class="headerlink" title="题型一     顺序表的逆置"></a>题型一     顺序表的逆置</h3><p>​        题意：将一个顺序表逆置：顺序表的逆置比起链表简单，此处不做过多声明。</p>
<p>​        代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a[MaxLength] 顺序表a , a的左边界left以及右边界right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReversed</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> left , <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left,j=right;i&lt;j;i++,j--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题型二-顺序表元素的移动"><a href="#题型二-顺序表元素的移动" class="headerlink" title="题型二      顺序表元素的移动"></a>题型二      顺序表元素的移动</h3><ol>
<li><p>将长度为n的数组前k(k&lt;n)个元素逆置移动到后端并要求元数据不发生丢失。</p>
<p>​    代码实现    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left,j=right;i&lt;left+k&amp;&amp;i&lt;j;i++,j--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        其中i<j是为了保证不发生多余交换进行限制；i < left + k 或者 j > right - k 时进行元素的交换。</p>
<p>2.将一个长度为n的数组前k(k&gt;0)个元素保持原序移动到数组后端并保证数据不丢失。</p>
</li>
</ol>
<p>​         代码实现    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToEndAdjust</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reverse(a, <span class="number">0</span>, k<span class="number">-1</span>, k);</span><br><span class="line">    reverse(a, <span class="number">0</span>, n<span class="number">-1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    3.将一个长度为n的数组a中的元素[a0,a1,a2,…]经过移动后变为[ap,ap-1,…,an-1,a0,a1,…,ap-1]；即循环左移p(0&lt;p&lt;n)个位置。</p>
<p>​        代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">movePosition</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reverse(a, <span class="number">0</span>, p<span class="number">-1</span>, p);</span><br><span class="line">    reverse(a, p, n<span class="number">-1</span>, n-p);</span><br><span class="line">    reverse(a, <span class="number">0</span>, n<span class="number">-1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题型三-最值相关"><a href="#题型三-最值相关" class="headerlink" title="题型三      最值相关"></a>题型三      最值相关</h3><p>​        以打擂台形式求最值，将第一个元素默认为最大/小值，并以此比较，若出小更大/小者，则取而代之成为“擂主”继续PK。</p>
<p>​        代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaximum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> &amp;pos ,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_max &lt; a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            m_max = a[i];</span><br><span class="line">            pos = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        pos用于记录最值出现的下标。</p>
<p>​        最小值类似，在此处就略过。</p>
<h3 id="题型四-归并"><a href="#题型四-归并" class="headerlink" title="题型四      归并"></a>题型四      归并</h3><p>​        归并：即将两个有序表合并为一个表。</p>
<p>​        代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">mergeArray</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *c = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    i = j = k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m &amp;&amp; j&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; b[j])</span><br><span class="line">            c[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c[k++] = b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m)</span><br><span class="line">        c[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;n)</span><br><span class="line">        c[k++] = b[j++];</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题型五-划分"><a href="#题型五-划分" class="headerlink" title="题型五      划分"></a>题型五      划分</h3><p>​        1.题意：以顺序表第一个元素为中心，使得任意小于他的元素在其左侧，大于他的在右侧。</p>
<p>​                代码实现：            </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span> , j = n - <span class="number">1</span>;</span><br><span class="line">    tmp = arr[i];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; arr[j] &gt;= tmp)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            arr[i++] = arr[j];</span><br><span class="line">        <span class="keyword">while</span>(arrp[i] &lt; tmp &amp;&amp; i&lt;j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            arr[j--] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        2.以任意元素为中心，是的排在其左侧的元素小于其，右侧元素均大于等于它。</p>
<p>​            实现：交换该位置元素与第一元素即可。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
